---
title: "Practica3"
author: "Anali y David"
date: "2026-01-19"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
``` 


```{r carga_libs, include=FALSE}
library(dplyr)
library(knitr)
library(readr)
library(stringr)
library(DT)
library(ggplot2)
library(data.table)
library(lubridate)
```

Análisis de logs de servidor usando R (parte II) 

### Pregunta 1:
Descomprimir el fichero comprimido que contiene los registros del 
servidor, y a partir de los datos extraídos, cargar en data frame los 
registros con las peticiones servidas. 

```{r carga_datos_base, echo=TRUE}
epa_http <- read_table("epa_http.csv", col_names = FALSE, show_col_types = F)
```

Aplicar nombres descriptivos a las columnas del DS/DF:
```{r categorizaciontablas_datos}
# Aplicar nombres descriptivos a las columnas del DS:
colnames(epa_http) <- c("FQDN/IP","TIMESTAMP","PETICION_HTTP","URL","PROTOCOLO","CODIGO_HTTP","BYTES_RESPUESTA")
```

### Pregunta 2:
  Incluid en el documento un apartado con la descripción de los datos
  analizados: fuente, tipología, descripción de la información contenida
  (los diferentes campos) y sus valores.

 - **Fuente:**  
      Profesorado (Arnau)

- **Tipología:**  
     Fichero de log de servidor web (Apache)

- **Descripción de la información:**  
     Los datos analizados corresponden a registros generados por un servidor web Apache.  
     Cada registro representa una petición HTTP realizada por un usuario al servidor.
     

### Pregunta 3: 
Aprovechando que los datos a analizar son los mismos de la primera 
práctica, para esta entrega es imprescindible que los datos estén en 
formato de “datos elegantes”. 

```{r limpieza_de_datos, echo=TRUE}
# Eliminación comillas 
epa_http$PETICION_HTTP <- str_replace(epa_http$PETICION_HTTP, "\"","")
epa_http$PROTOCOLO <- str_replace(epa_http$PROTOCOLO, "\"","")

# Convertir a factor
epa_http$PETICION_HTTP <- as.factor(epa_http$PETICION_HTTP)
epa_http$PROTOCOLO <- as.factor(epa_http$PROTOCOLO)

# Extraer tiempo (adición nueva columna HORA) 
epa_http$HORA <- str_sub(epa_http$TIMESTAMP, start =5, end=6)

# Transformar el campo BYTES_RESPUESTA en entero y cambiar "-" por NA 
epa_http$BYTES_RESPUESTA[epa_http$BYTES_RESPUESTA == "-"] <- NA
epa_http$BYTES_RESPUESTA[epa_http$BYTES_RESPUESTA == "0"] <- NA
epa_http$BYTES_RESPUESTA <- as.numeric(epa_http$BYTES_RESPUESTA)
```

### Pregunta 4:
Identificar el número único de usuarios que han interactuado 
directamente con el servidor de forma segregada según si los usuarios 
han tenido algún tipo de error en las distintas peticiones ofrecidas por el 
servidor.

```{r get_resp_code,echo=TRUE}
# Mostrar los errores por el acceso del usuario
respuestas_erroneas <- epa_http %>%
  filter(CODIGO_HTTP >= 400) %>%
  count(`FQDN/IP`, CODIGO_HTTP, name = "ERRORES") %>%
  arrange(desc(ERRORES))

# Mostrar la tabla de errores completa
datatable(
  respuestas_erroneas,
  options = list(
    pageLength = 10,   # Número de filas por página
    lengthMenu = c(5, 10, 20, 50),
    scrollY = "400px",
    scrollCollapse = TRUE
  )
)
```

### Pregunta 5:
Analizar los distintos tipos de peticiones HTTP (GET, POST, PUT, DELETE) 
gestionadas por el servidor, identificando la frecuencia de cada una de 
estas. 

```{r get_resp_http_by_type,echo=TRUE}
# Obtener tipos de respuesta por tipo de HTTP y sus frecuencias
respuestas_tipo <- epa_http %>%
  #En este caso separadas por tipo de petición. Lo comento ya que NO se nos pide 
  #count(PETICION_HTTP, CODIGO_HTTP, name = "NUM_PETIS") %>%
  count(PETICION_HTTP, name = "NUM_PETIS") %>%
  arrange(desc(NUM_PETIS))

# Mostrar la tabla de errores completa
datatable(
  respuestas_tipo,
  options = list(
    pageLength = 15,   # Número de filas por página
    lengthMenu = c(5, 10, 20),
    scrollY = "400px",
    scrollCollapse = TRUE
  )
)
```

### Pregunta 5.1 bis: 
Repetir el análisis, esta vez filtrando previamente aquellas 
peticiones correspondientes a recursos ofrecidos de tipo imagen. 
```{r get_resp_http_by_type_image,echo=TRUE}
# Mostrar Obtener tipos de peticiones que contengan recursos tipo imagen y sus frecuencias 
respuestas_tipo_imagen <- epa_http %>%
filter(str_detect(URL, "\\.(jpg|jpeg|png|gif|bmp|webp)$"))%>%
count(PETICION_HTTP, name = "NUM_PETIS_WITH_IMAGES") %>%
arrange(desc(NUM_PETIS_WITH_IMAGES))

# Mostrar la tabla de errores completa
datatable(
  respuestas_tipo_imagen,
  options = list(
    pageLength = 15,   # Número de filas por página
    lengthMenu = c(5, 10, 20),
    scrollY = "400px",
    scrollCollapse = TRUE
  )
)
``` 

### Pregunta 6:
Generar al menos 2 gráficos distintos que permitan visualizar alguna 
característica relevante de los datos analizados.  
Estos deberán representar por lo menos 1 o 2 variables diferentes del 
data frame. Describid el gráfico e indicad cualquier observación 
destacable que se pueda apreciar gracias a la representación gráfica. 

```{r Pregunta6,echo=TRUE}
ggplot(respuestas_tipo, aes(x = PETICION_HTTP, y = NUM_PETIS, fill = PETICION_HTTP)) +
  geom_col(color = "black", alpha = 0.85) +
  scale_fill_brewer(palette = "Set2") +
  labs(
    title = "Frecuencia de tipos de peticiones HTTP",
    x = "Tipo de petición HTTP",
    y = "Número de peticiones"
  ) +
  theme_minimal() +
  theme(
    legend.position = "none",
    plot.title = element_text(face = "bold", size = 14)
  )
```

**Descripción del gráfico:**  
   El gráfico muestra la frecuencia de cada tipo de petición HTTP registrada en el servidor.

**Interpretación:**  
  Se observa que el método GET es el más utilizado, lo cual es típico en servidores web que sirven contenido estático.       Otros métodos como POST o HEAD aparecen con menor frecuencia, indicando un uso limitado de operaciones que implican envío   de datos.

```{r Pregunta6.1,echo=TRUE}
epa_http %>%
  filter(CODIGO_HTTP >= 400) %>%
  count(CODIGO_HTTP) %>%
  ggplot(aes(x = factor(CODIGO_HTTP), y = n, fill = factor(CODIGO_HTTP))) +
  geom_col(alpha = 0.9) +
  scale_fill_brewer(palette = "Reds") +
  labs(
    title = "Distribución de códigos de error HTTP",
    x = "Código de error HTTP",
    y = "Número de peticiones"
  ) +
  theme_minimal() +
  theme(
    legend.position = "none",
    plot.title = element_text(face = "bold", size = 14)
  )
```

**Descripción del gráfico:**  
   El gráfico muestra la frecuencia de cada tipo de petición HTTP registrada en el servidor.

**Interpretación:**  
  Se observa que el método GET es el más utilizado, lo cual es típico en servidores web que sirven contenido estático.       Otros métodos como POST o HEAD aparecen con menor frecuencia, indicando un uso limitado de operaciones que implican envío   de datos.


### Pregunta 7:
Generar un gráfico que permita visualizar el número de peticiones 
servidas a lo largo del tiempo. 

```{r Pregunta7, echo=TRUE}
library(lubridate)

# Limpiar el timestamp tipo Apache: quitar corchetes y quedarnos con la parte de fecha-hora
epa_http <- epa_http %>%
  mutate(
    TS_LIMPIO = str_sub(TIMESTAMP, 2, 20),          # "[01/Jul/1995:00:00:01" -> "01/Jul/1995:00:00:01"
    FECHA_HORA = dmy_hms(TS_LIMPIO),                # convertir a POSIXct
    HORA_DIA = hour(FECHA_HORA)                     # extraer la hora (0–23)
  )

peticiones_por_hora <- epa_http %>%
  count(HORA_DIA)

peticiones_por_hora$HORA_DIA <- factor(
  peticiones_por_hora$HORA_DIA,
  levels = 0:23
)

ggplot(peticiones_por_hora, aes(x = HORA_DIA, y = n, group = 1)) +
  geom_line() +
  geom_point() +
  labs(
    title = "Número de peticiones servidas por hora",
    x = "Hora del día",
    y = "Número de peticiones"
  ) +
  theme_minimal()


```




### Pregunta 8:
Utilizando un algoritmo de aprendizaje no supervisado, realizad un 
análisis de clústering con k-means para los datos del servidor. 

 Para este análisis debéis repetir la ejecución del modelado con 
distintos valores de k (número de clústeres) con al menos 2 valores 
diferentes de k. 
• A fin de retener algo de información sobre el recurso servido, generad 
una columna numérica derivada de esta con el número de caracteres 
de la URL servida. 


### Pregunta 9:
Representad visualmente en gráficos de tipo scatter plot el resultado de 
vuestros clústering y interpretad el resultado obtenido (describid las 
características de los distintos grupos) con los 2 valores distintos de k 
probados en el apartado anterior en función de los valores de las variables y 
el número de clúster asignado. 
