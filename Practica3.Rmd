---
title: "Practica3"
author: "Anali y David"
date: "2026-01-19"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
``` 


```{r carga_libs, include=FALSE}
library(dplyr)
library(knitr)
library(readr)
library(stringr)
library(DT)

```

Análisis de logs de servidor usando R (parte II) 

### Pregunta 1:
Descomprimir el fichero comprimido que contiene los registros del 
servidor, y a partir de los datos extraídos, cargar en data frame los 
registros con las peticiones servidas. 

```{r carga_datos_base, echo=TRUE}
epa_http <- read_table("epa_http.csv", col_names = FALSE, show_col_types = F)
```

Aplicar nombres descriptivos a las columnas del DS/DF:
```{r categorizaciontablas_datos}
# Aplicar nombres descriptivos a las columnas del DS:
colnames(epa_http) <- c("FQDN/IP","TIMESTAMP","PETICION_HTTP","URL","PROTOCOLO","CODIGO_HTTP","BYTES_RESPUESTA")
```

### Pregunta 2:
  Incluid en el documento un apartado con la descripción de los datos
  analizados: fuente, tipología, descripción de la información contenida
  (los diferentes campos) y sus valores.

 - **Fuente:**  
      Profesorado (Arnau)

- **Tipología:**  
     Fichero de log de servidor web (Apache)

- **Descripción de la información:**  
     Los datos analizados corresponden a registros generados por un servidor web Apache.  
     Cada registro representa una petición HTTP realizada por un usuario al servidor.
     

### Pregunta 3: 
Aprovechando que los datos a analizar son los mismos de la primera 
práctica, para esta entrega es imprescindible que los datos estén en 
formato de “datos elegantes”. 

```{r limpieza_de_datos, echo=TRUE}
# Eliminación comillas 
epa_http$PETICION_HTTP <- str_replace(epa_http$PETICION_HTTP, "\"","")
epa_http$PROTOCOLO <- str_replace(epa_http$PROTOCOLO, "\"","")

# Convertir a factor
epa_http$PETICION_HTTP <- as.factor(epa_http$PETICION_HTTP)
epa_http$PROTOCOLO <- as.factor(epa_http$PROTOCOLO)

# Extraer tiempo (adición nueva columna HORA) 
epa_http$HORA <- str_sub(epa_http$TIMESTAMP, start =5, end=6)

# Transformar el campo BYTES_RESPUESTA en entero y cambiar "-" por NA 
epa_http$BYTES_RESPUESTA[epa_http$BYTES_RESPUESTA == "-"] <- NA
epa_http$BYTES_RESPUESTA[epa_http$BYTES_RESPUESTA == "0"] <- NA
epa_http$BYTES_RESPUESTA <- as.numeric(epa_http$BYTES_RESPUESTA)
```

### Pregunta 4:
Identificar el número único de usuarios que han interactuado 
directamente con el servidor de forma segregada según si los usuarios 
han tenido algún tipo de error en las distintas peticiones ofrecidas por el 
servidor.

```{r get_resp_code,echo=TRUE}
# Mostrar los errores por el acceso del usuario
respuestas_erroneas <- epa_http %>%
  filter(CODIGO_HTTP >= 400) %>%
  count(`FQDN/IP`, CODIGO_HTTP, name = "ERRORES") %>%
  arrange(desc(ERRORES))

# Mostrar la tabla de errores completa
datatable(
  respuestas_erroneas,
  options = list(
    pageLength = 10,   # Número de filas por página
    lengthMenu = c(5, 10, 20, 50),
    scrollY = "400px",
    scrollCollapse = TRUE
  )
)
```

### Pregunta 5:
Analizar los distintos tipos de peticiones HTTP (GET, POST, PUT, DELETE) 
gestionadas por el servidor, identificando la frecuencia de cada una de 
estas. 

```{r get_resp_http_by_type,echo=TRUE}
# Obtener tipos de respuesta por tipo de HTTP y sus frecuencias
respuestas_tipo <- epa_http %>%
  #En este caso separadas por tipo de petición. Lo comento ya que NO se nos pide 
  #count(PETICION_HTTP, CODIGO_HTTP, name = "NUM_PETIS") %>%
  count(PETICION_HTTP, name = "NUM_PETIS") %>%
  arrange(desc(NUM_PETIS))

# Mostrar la tabla de errores completa
datatable(
  respuestas_tipo,
  options = list(
    pageLength = 15,   # Número de filas por página
    lengthMenu = c(5, 10, 20),
    scrollY = "400px",
    scrollCollapse = TRUE
  )
)
```

### Pregunta 5.1 bis: 
Repetir el análisis, esta vez filtrando previamente aquellas 
peticiones correspondientes a recursos ofrecidos de tipo imagen. 
```{r get_resp_http_by_type_image,echo=TRUE}
# Mostrar Obtener tipos de peticiones que contengan recursos tipo imagen y sus frecuencias 
respuestas_tipo_imagen <- epa_http %>%
filter(str_detect(URL, "\\.(jpg|jpeg|png|gif|bmp|webp)$"))%>%
count(PETICION_HTTP, name = "NUM_PETIS_WITH_IMAGES") %>%
arrange(desc(NUM_PETIS_WITH_IMAGES))

# Mostrar la tabla de errores completa
datatable(
  respuestas_tipo_imagen,
  options = list(
    pageLength = 15,   # Número de filas por página
    lengthMenu = c(5, 10, 20),
    scrollY = "400px",
    scrollCollapse = TRUE
  )
)
``` 

### Pregunta 6:
Generar al menos 2 gráficos distintos que permitan visualizar alguna 
característica relevante de los datos analizados.  
Estos deberán representar por lo menos 1 o 2 variables diferentes del 
data frame. Describid el gráfico e indicad cualquier observación 
destacable que se pueda apreciar gracias a la representación gráfica. 

### Pregunta 7:
Generar un gráfico que permita visualizar el número de peticiones 
servidas a lo largo del tiempo. 

### Pregunta 8:
Utilizando un algoritmo de aprendizaje no supervisado, realizad un 
análisis de clústering con k-means para los datos del servidor. 

### Pregunta 9:
Representad visualmente en gráficos de tipo scatter plot el resultado de 
vuestros clústering y interpretad el resultado obtenido (describid las 
características de los distintos grupos) con los 2 valores distintos de k 
probados en el apartado anterior en función de los valores de las variables y 
el número de clúster asignado. 
